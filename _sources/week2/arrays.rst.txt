:tocdepth: 2

.. _week2_arrays:

Arrays
================

.. contents:: :local:

.. highlight:: python

Translating Vectors to Arrays
-----------------------------

.. NTS:

   note that at the moment we are ignoring differences between row/col
   matrices?

Up to this point, we have discussed storing one value at a time in a
variable, translating scalar quantities to computational types like
int, float, bool and complex.  What about when we have algebraic
things like vectors and matrices?

Consider an example case of a velocity vector, which might be written
in a physics textbook as:
  
  :math:`\textbf{v}  = ( v_x, v_y, v_z )`

Sometimes different sets of indices are used, and this could also be
written using a common, and slightly more general, mathematical
notation as either:

  :math:`\textbf{v} = ( v_1, v_2, v_3 )~~~~~~{\rm or}~~~~~~\textbf{v} = ( v_0,
  v_1, v_2 )`

In each case, the *i*\th component is referenced as :math:`v_i`, with
allowed values of *i* determined by the length of the vector.

When we translate this to Python, we have all the same parts, but some
have slightly different names and we use just one, particular syntax.

The above vector :math:`\textbf{v}` is stored as an **array** ``v``;
there is no bold font or arrow we can use to denote it as a vector, we
just have to remember it or perhaps reflect it in the variable
name. Instead of "components", we refer to **elements** of ``v``, which
would be accessed as:

   ``v[0], v[1], v[2]``.

We still refer to **indices**, but since we don't have subscripts, we
put them in square brackets.  The indices are always numbers, counting
from zero, which is called **zero-based counting**.  (Note that
different programming languages have different counting systems; C and
C++ use zero-based counting, while Fortran, R and Matlab count from
one.) 

The index notation carries directly to mathematical matrices.  In
computing, these are just referred to as multidimensional arrays, or
more commonly just "arrays (in actual fact, a multidimensional array
is just an array whose elements are also arrays, an "array of arrays",
but that normally is not relevant when using them). All the above
notations and terms apply.  Matrices typically have multiple
dimensions and therefore multiple indices; these also translate
directly from subscripts in the mathematics to square brackets in
computing.  For example, the element in the first row and column of a
2-dimensional matrix :math:`\mathbf{A}` would be ``A[0,0]``; the next
element in the column would be ``A[1,0]``; etc.

The following table summarizes the translation from mathematical
vectors to computational arrays:

  .. list-table::
     :header-rows: 1
     :widths: 25 5 30

     * - Math name 
       - :math:`\rightarrow`
       - Comp name
     * - vector
       - :math:`\rightarrow`
       - array
     * - component
       - :math:`\rightarrow`
       - element
     * - index
       - :math:`\rightarrow`
       - index
     * - subscript
       - :math:`\rightarrow`
       - square bracket, ``[ ]``
     * - *example:* :math:`~~\displaystyle x_0`
       - :math:`\rightarrow`
       - ``x[0]``
     * - *example:* :math:`~~\displaystyle M_{0,4}`
       - :math:`\rightarrow`
       - ``M[0,4]``

Thus, the array notation closely follows that of the
mathematics/physics communities, with some small notational
differences.  And, importantly, much of the *mathematics* for
computing with vectors will also translate directly into programs, as
well.

Creating arrays
###############

There are many ways to assign values to arrays in Python.  In each
case, when we create an array we need its define:

1. the **length** or **shape** (dimensions),

#. the type of its elements, and

#. initial values for all the elements (which may be altered later).

Note that *all* elements of an array are of a single type (i.e., one
cannot mix floats and ints in an array); and to distinguish the issue
of element type from the array's own type, the former's type is
referring to as a **datatype** (or **dtype**, an abbreviation often
used in helpfiles).

The need to define both dimensions and element types matches both 

* formal mathematical correctness, such as stating:

  :math:`\textbf{v} \in \mathbb{R}^4`; that is, **v** a vector
  contains 4 real numbers,

  :math:`\textbf{g} \in \mathbb{R}^{4\times4}`; that is, **g** is a
  4-by-4 matrix of real numbers,

  :math:`\textbf{c} \in \mathbb{C}^{2\times3}`; that is, **c** is a
  2-by-3 matrix of complex numbers,

  etc.

* and computational space requirements, so Python knows how much space
  to allocate (dimensionality determines number of total spots,
  and element datatype determines the size of each).
  
Here and below, whenever using arrays, we will be importing NumPy,
which contains most of the functions we will use.

* Most basically, one can make an array directly using the
  ``np.array()`` function::

    import numpy as np

    v = np.array([4, 5, 6])
    print(v)
    print(v[0])

  We see that ``v`` contains three elements, and that the [0]th is 4
  (as expected).  Each object in python has a type, and we can check
  the type of ``v``. 
  
    type(v)

  Additionally, the *elements* of ``v`` have a type as well::

    print(type(v[0]))

    
|

|

|



Practice 1
##########

#. Make the following arrays:

   i. :math:`\textbf{v} = (-1.1, 5, 7.6)`

   #. :math:`\textbf{u} = (2, 4, 6)`

   #. :math:`\textbf{w} = (2+3i, -4-3j, 6)`

   #. An :math:`2\times3`

   #. An array of 

.. old examples

    i. What are the types of each of the following?

       .. code-block:: python
          :linenos:

          -1
          20.00001
          10**19
          10**19 - 10**19
          1 + 0j
          1
          False

    #. What are the values (and types-- difficult properties to separate
       in some cases!) of the following?::

         2 + True
         4.5 - 3
         4.5 / 3
         5 + 3
         5 / 3
         5 / 3.
         5 // 3.
         5 + 5.j / 3
         5 + 5.j // 3
         4.7 % 3
